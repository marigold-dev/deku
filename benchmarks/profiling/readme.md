# Profiling Deku-node

## Profiling Deku-node using Linux [perf](https://www.brendangregg.com/perf.html)


### Setup
Setting `perf` to run without super-user permission (allow non-root users)

```
sudo sh -c 'echo -1 >/proc/sys/kernel/perf_event_paranoid'
sudo sysctl -w kernel.perf_event_paranoid=-1
sudo sh -c 'echo kernel.perf_event_paranoid=-1 > /etc/sysctl.d/local.conf'
```

`perf_event_paranoid` setting is 1:
- `-1`: Allow use of (almost) all events by all users
      Ignore mlock limit after perf_event_mlock_kb without CAP_IPC_LOCK
- `>= 0`: Disallow raw and ftrace function tracepoint - access
- `>= 1`: Disallow CPU event access
- `>= 2`: Disallow kernel profiling

To make the adjusted `perf_event_paranoid` setting permanent preserve it
in `/etc/sysctl.conf` (e.g. `kernel.perf_event_paranoid = <setting>`)

### Run

```
./profile_deku.sh run
```

Profile deku node with perf:
- Tear down the deku node
- Setup deku environments
- Start deku clusters and use `perf` to get the profiling data

  The samples are saved in a `perf.data` file. This does involve CPU, file system, and disk overheads to save the samples to the file system for later processing.
 - Sleep for 10 seconds


<!------------------------------------------------------------------------>

##  Read `perf.data`
### [FlameGraph](https://github.com/brendangregg/FlameGraph)

Read `perf.data` using FlameGraph. FlameGraph needs to be downloaded:
 `git clone https://github.com/brendangregg/FlameGraph`

Run this script only when `perf record` is **properly terminated** (a.k.a: `./profile_deku.sh run`).

```
./profile_deku.sh flame-graph
```

Wait for awhile to let the graph generated. The result in picture as `perf-deku-flamegraph.svg`. You can use internet browser to see it `firefox perf-deku-flamegraph.svg` or chrome, etc.

#### Understand Flamegraph
It shows: 
- x-axis: show the stack profile (the sample) population, sorted alphabetically
- y-axis: stack depth, counting from zero at the bottom.
- Each function (stack frame) is drawn as a rectangle, with the width relative to the number of samples. The wider a frame is, the more often it was present in the stacks.
- The top edge shows what is on-CPU.
- The beneath it is its ancestry.
- The colors are usually not significant, picked randomly to differentiate frames.

### Callgraph [gprof2dot](https://github.com/jrfonseca/gprof2dot)

Read `perf.data` generated by Linux perf using `gprof2dot`.

#### Setup

Install on Debian/Ubuntu run first:

```
 sudo apt-get install python3 graphviz
 sudo apt-get install python3-pip
 sudo pip install gprof2dot
```

Wait for awhile to let the graph generated. The result in picture as `perf-deku-callgraph.png`. You can use internet browser to see it `firefox perf-deku-call-graph.png` or chrome, etc.

#### Run

Run this script only when `perf record` is **properly terminated** (a.k.a: `./profile_deku.sh run`).

```
./profile_deku.sh call-graph
```

### Read `perf.data` with [Hotspot](https://github.com/KDAB/hotspot)

#### Setup 

Install hotspot on Debian/Ubuntu

```
add-apt-repository ppa:kubuntu-ppa/backports
apt-get update
apt-get install libkf5threadweaver-dev libkf5i18n-dev libkf5configwidgets-dev \
    libkf5coreaddons-dev libkf5itemviews-dev libkf5itemmodels-dev libkf5kio-dev libkf5parts-dev \
    libkf5solid-dev libkf5windowsystem-dev libkf5notifications-dev libkf5iconthemes-dev libelf-dev \
    libdw-dev cmake extra-cmake-modules gettext libqt5svg5-dev

apt-get install hotspot
```

#### Run 
Use hotspot to read `perf.data`: 

```
hotspot /path/to/perf.data
```

<!------------------------------------------------------------------------>

## Memory profiling the C heap

 Using [valgrind](https://valgrind.org/) with [massif](https://valgrind.org/docs/manual/ms-manual.html). 
 
 Valgrind basically runs the program in a "sandbox". While running in this sandbox, it is able to insert its own instructions to do advanced debugging and profiling.
 Before the application instructions are processed, they are passed to tools (such as memcheck (default)). These tools like plugins, and they are able to modify the program before it it run on the processor.
 Valgrind does cause the program to run slower, however it is not meant to measure performance. 

 ``` 
   valgrind tool = valgrind core + tool plugin
  ```

 Massif is a heap profiler. It measures how much heap memory your program uses. This includes both the useful space, and the extra bytes allocated for book-keeping and alignment purposes. It can also measure the size of your program's stack(s), although it does not do so by default.

### Setup
- Install `valgrind` : `sudo apt install valgrind`

- Install viewer `massif-visualizer`:

  Run `valgrind` with the option `--tool=massif`.
  Massif will print summary space statistics. It puts detailed information about heap consumption in a file `massif.pid.out`, where `pid` is the program's process id. 
  

```
sudo add-apt-repository ppa:kubuntu-ppa/backports 
sudo apt-get update
sudo apt-get install massif-visualizer
```

- Install viewer `kachegrind`: 

  Run `valgrind` with the option `--xtree-memory=full`, it will generate a call tree, which can then be inspected using `kachegrind`. The call tree filename is `xtmemory.kcg.[pid]` .

```
sudo apt update
sudo apt-get install kcachegrind
```

### Run
Profile deku node with valgrind:
- Tear down the deku node
- Setup deku environments
- Start deku clusters and use `valgrind` to get the profiling data

```
./profile_deku.sh memory-profile
```

### Understand the graph
#### Massif

The graph is broken into several bands. 

- x-axis: the time on the x-axis is wallclock time.
- y-axis: It is the height of a band that's important. Most bands represent a single line of the program that does some heap allocation; each such band represents all the allocations and deallocations done from that line. 
