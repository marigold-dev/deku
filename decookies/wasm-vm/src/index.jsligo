#include "constants.jsligo"
#include "utils.jsligo"
const main = 
  ([ope, cookieBakers]: 
    [parameter,
     storage]): return_ => {return [list([]),
    match(ope, {Mint: (m: mint) => {match(m.operation, {Cookie: () => {let player: address = 
          m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookies = 
           cookieBaker.cookies + (m.amount as nat);
         let cookieBakers = 
           Big_map.update(player as address, Some
             ({...cookieBaker, cookies: cookies}), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Cursor: () => {let player = m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookieBaker: cookieBaker = 
           force_access(player as address, cookieBakers);
         if(cookieBaker.cookies >= cookieBaker.cursorCost) {let cursors = 
            cookieBaker.cursors + (1 as nat);
          let cookies = 
            abs(cookieBaker.cookies - cookieBaker.cursorCost);
          let updatedCookieBaker = 
            {...cookieBaker,
             cookies: cookies,
             cursors: cursors};
          let cursorCost = 
            calculateCost(m.operation, updatedCookieBaker);
          let passiveCPS = calculateCPS(updatedCookieBaker);
          let updatedCookieBaker = 
            {...updatedCookieBaker,
             cursorCost: cursorCost,
             passiveCPS: passiveCPS};
          let cookieBakers = 
            Big_map.update(player as address, Some
              (updatedCookieBaker), cookieBakers);
          return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
       Grandma: () => {let player = m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookieBaker: cookieBaker = 
           force_access(player as address, cookieBakers);
         if(cookieBaker.cookies >= cookieBaker.grandmaCost) {let grandmas = 
            cookieBaker.grandmas + (1 as nat);
          let cookies = 
            abs(cookieBaker.cookies - cookieBaker.grandmaCost);
          let updatedCookieBaker = 
            {...cookieBaker,
             cookies: cookies,
             grandmas: grandmas};
          let grandmaCost = 
            calculateCost(m.operation, updatedCookieBaker);
          let passiveCPS = calculateCPS(updatedCookieBaker);
          let updatedCookieBaker = 
            {...updatedCookieBaker,
             grandmaCost: grandmaCost,
             passiveCPS: passiveCPS};
          let cookieBakers = 
            Big_map.update(player as address, Some
              (updatedCookieBaker), cookieBakers);
          return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
       Farm: () => {let player = m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookieBaker: cookieBaker = 
           force_access(player as address, cookieBakers);
         if(cookieBaker.cookies >= cookieBaker.farmCost) {let farms = 
            cookieBaker.farms + (1 as nat);
          let cookies = 
            abs(cookieBaker.cookies - cookieBaker.farmCost);
          let updatedCookieBaker = 
            {...cookieBaker, cookies: cookies, farms: farms};
          let farmCost = 
            calculateCost(m.operation, updatedCookieBaker);
          let passiveCPS = calculateCPS(updatedCookieBaker);
          let updatedCookieBaker = 
            {...updatedCookieBaker,
             farmCost: farmCost,
             passiveCPS: passiveCPS};
          let cookieBakers = 
            Big_map.update(player as address, Some
              (updatedCookieBaker), cookieBakers);
          return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
       Mine: () => {let player = m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookieBaker: cookieBaker = 
           force_access(player as address, cookieBakers);
         if(cookieBaker.cookies >= cookieBaker.mineCost) {let mines = 
            cookieBaker.mines + (1 as nat);
          let cookies = 
            abs(cookieBaker.cookies - cookieBaker.mineCost);
          let updatedCookieBaker = 
            {...cookieBaker, cookies: cookies, mines: mines};
          let mineCost = 
            calculateCost(m.operation, updatedCookieBaker);
          let passiveCPS = calculateCPS(updatedCookieBaker);
          let updatedCookieBaker = 
            {...updatedCookieBaker,
             mineCost: mineCost,
             passiveCPS: passiveCPS};
          let cookieBakers = 
            Big_map.update(player as address, Some
              (updatedCookieBaker), cookieBakers);
          return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
       Factory: () => {let player = m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookieBaker: cookieBaker = 
           force_access(player as address, cookieBakers);
         if(cookieBaker.cookies >= cookieBaker.factoryCost) {let factories = 
            cookieBaker.factories + (1 as nat);
          let cookies = 
            abs(cookieBaker.cookies - cookieBaker.factoryCost);
          let updatedCookieBaker = 
            {...cookieBaker,
             cookies: cookies,
             factories: factories};
          let factoryCost = 
            calculateCost(m.operation, updatedCookieBaker);
          let passiveCPS = calculateCPS(updatedCookieBaker);
          let updatedCookieBaker = 
            {...updatedCookieBaker,
             factoryCost: factoryCost,
             passiveCPS: passiveCPS};
          let cookieBakers = 
            Big_map.update(player as address, Some
              (updatedCookieBaker), cookieBakers);
          return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
       Bank: () => {let player = m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookieBaker: cookieBaker = 
           force_access(player as address, cookieBakers);
         if(cookieBaker.cookies >= cookieBaker.bankCost) {let banks = 
            cookieBaker.banks + (1 as nat);
          let cookies = 
            abs(cookieBaker.cookies - cookieBaker.bankCost);
          let updatedCookieBaker = 
            {...cookieBaker, cookies: cookies, banks: banks};
          let bankCost = 
            calculateCost(m.operation, updatedCookieBaker);
          let passiveCPS = calculateCPS(updatedCookieBaker);
          let updatedCookieBaker = 
            {...updatedCookieBaker,
             bankCost: bankCost,
             passiveCPS: passiveCPS};
          let cookieBakers = 
            Big_map.update(player as address, Some
              (updatedCookieBaker), cookieBakers);
          return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
       Temple: () => {let player = m.onBehalfOf;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let isAuthorized: bool = 
          Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
           as set<address>);
        if(isAuthorized) {let cookieBaker: cookieBaker = 
           force_access(player as address, cookieBakers);
         if(cookieBaker.cookies >= cookieBaker.templeCost) {let temples = 
            cookieBaker.temples + (1 as nat);
          let cookies = 
            abs(cookieBaker.cookies - cookieBaker.templeCost);
          let updatedCookieBaker = 
            {...cookieBaker,
             cookies: cookies,
             temples: temples};
          let templeCost = 
            calculateCost(m.operation, updatedCookieBaker);
          let passiveCPS = calculateCPS(updatedCookieBaker);
          let updatedCookieBaker = 
            {...updatedCookieBaker,
             templeCost: templeCost,
             passiveCPS: passiveCPS};
          let cookieBakers = 
            Big_map.update(player as address, Some
              (updatedCookieBaker), cookieBakers);
          return cookieBakers} else {return cookieBakers}} else {return cookieBakers}}})},
     Eat: eat => {let player = eat.onBehalfOf;
      let cookieBaker: cookieBaker = 
        force_access(player as address, cookieBakers);
      let isAuthorized: bool = 
        Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
         as set<address>);
      if(isAuthorized) {let cookieBaker: cookieBaker = 
         force_access(player as address, cookieBakers);
       if(cookieBaker.cookies >= eat.amount) {let eatenCookies = 
          cookieBaker.eatenCookies + (eat.amount as nat);
        let cookies = 
          abs(cookieBaker.cookies - (eat.amount as nat));
        let cookieBakers = 
          Big_map.update(player as address, Some
            ({...cookieBaker,
             cookies: cookies,
             eatenCookies: eatenCookies}), cookieBakers);
        return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
     Transfer: transfer => {let player = transfer.onBehalfOf;
      let cookieBaker: cookieBaker = 
        force_access(player as address, cookieBakers);
      let isAuthorized: bool = 
        Set.mem(Tezos.get_sender(), cookieBaker.authorizedKeys
         as set<address>);
      if(isAuthorized) {let sender: cookieBaker = 
         force_access(player as address, cookieBakers);
       if(sender.cookies >= transfer.amount) {let rawRecipient = 
          transfer.recipient;
        let recipient = 
          force_access(rawRecipient as address, cookieBakers);
        let cookiesToTransfer = transfer.amount as nat;
        let senderCookies = 
          sender.cookies - cookiesToTransfer;
        let recipientCookies = 
          recipient.cookies + cookiesToTransfer;
        let cookieBakers = 
          Big_map.update(player as address, Some
            ({...sender, cookies: abs(senderCookies)}), cookieBakers);
        let cookieBakers = 
          Big_map.update(rawRecipient as address, Some
            ({...recipient, cookies: recipientCookies}), cookieBakers);
        return cookieBakers} else {return cookieBakers}} else {return cookieBakers}},
     Delegate: delegation => {let player = 
        Tezos.get_sender();
      let cookieBaker: cookieBaker = 
        force_access(player as address, cookieBakers);
      let authorizedKeys = 
        Set.add(delegation.authorizedKey, cookieBaker.authorizedKeys);
      let cookieBakers = 
        Big_map.update(player as address, Some
          ({...cookieBaker, authorizedKeys: authorizedKeys}), cookieBakers);
      return cookieBakers}})]};
