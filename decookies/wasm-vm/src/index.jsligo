#include "constants.jsligo"
#include "utils.jsligo"
const main = 
  ([ope, cookieBakers]: 
    [parameter,
     storage]): return_ => {
   return [list([]),
    match(ope, {Mint: (m: mint) => {match(m.operation, {Cookie: () => {
      let player = m.layerOneAddress;
      let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        let cookies = 
          cookieBaker.cookies + (m.amount as nat);
        let cookieBakers = 
          Map.update(player as address, Some
            ({...cookieBaker, cookies: cookies}), cookieBakers);
        return cookieBakers},
       Cursor: () => {
        let player = m.layerOneAddress;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.cursorCost) {let cursors = 
           cookieBaker.cursors + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.cursorCost);
         let updatedCookieBaker = 
           {...cookieBaker,
            cookies: cookies,
            cursors: cursors};
         let cursorCost = 
           calculateCost(m.operation, updatedCookieBaker);
         let passiveCPS = calculateCPS(updatedCookieBaker);
         let updatedCookieBaker = 
           {...updatedCookieBaker,
            cursorCost: cursorCost,
            passiveCPS: passiveCPS};
         let cookieBakers = 
           Map.update(player as address, Some
             (updatedCookieBaker), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Grandma: () => {
        let player = m.layerOneAddress;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.grandmaCost) {let grandmas = 
           cookieBaker.grandmas + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.grandmaCost);
         let updatedCookieBaker = 
           {...cookieBaker,
            cookies: cookies,
            grandmas: grandmas};
         let grandmaCost = 
           calculateCost(m.operation, updatedCookieBaker);
         let passiveCPS = calculateCPS(updatedCookieBaker);
         let updatedCookieBaker = 
           {...updatedCookieBaker,
            grandmaCost: grandmaCost,
            passiveCPS: passiveCPS};
         let cookieBakers = 
           Map.update(player as address, Some
             (updatedCookieBaker), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Farm: () => {
        let player = m.layerOneAddress;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.farmCost) {let farms = 
           cookieBaker.farms + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.farmCost);
         let updatedCookieBaker = 
           {...cookieBaker, cookies: cookies, farms: farms};
         let farmCost = 
           calculateCost(m.operation, updatedCookieBaker);
         let passiveCPS = calculateCPS(updatedCookieBaker);
         let updatedCookieBaker = 
           {...updatedCookieBaker,
            farmCost: farmCost,
            passiveCPS: passiveCPS};
         let cookieBakers = 
           Map.update(player as address, Some
             (updatedCookieBaker), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Mine: () => {
        let player = m.layerOneAddress;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.mineCost) {let mines = 
           cookieBaker.mines + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.mineCost);
         let updatedCookieBaker = 
           {...cookieBaker, cookies: cookies, mines: mines};
         let mineCost = 
           calculateCost(m.operation, updatedCookieBaker);
         let passiveCPS = calculateCPS(updatedCookieBaker);
         let updatedCookieBaker = 
           {...updatedCookieBaker,
            mineCost: mineCost,
            passiveCPS: passiveCPS};
         let cookieBakers = 
           Map.update(player as address, Some
             (updatedCookieBaker), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Factory: () => {
        let player = m.layerOneAddress;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.factoryCost) {let factories = 
           cookieBaker.factories + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.factoryCost);
         let updatedCookieBaker = 
           {...cookieBaker,
            cookies: cookies,
            factories: factories};
         let factoryCost = 
           calculateCost(m.operation, updatedCookieBaker);
         let passiveCPS = calculateCPS(updatedCookieBaker);
         let updatedCookieBaker = 
           {...updatedCookieBaker,
            factoryCost: factoryCost,
            passiveCPS: passiveCPS};
         let cookieBakers = 
           Map.update(player as address, Some
             (updatedCookieBaker), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Bank: () => {
        let player = m.layerOneAddress;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.bankCost) {let banks = 
           cookieBaker.banks + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.bankCost);
         let updatedCookieBaker = 
           {...cookieBaker, cookies: cookies, banks: banks};
         let bankCost = 
           calculateCost(m.operation, updatedCookieBaker);
         let passiveCPS = calculateCPS(updatedCookieBaker);
         let updatedCookieBaker = 
           {...updatedCookieBaker,
            bankCost: bankCost,
            passiveCPS: passiveCPS};
         let cookieBakers = 
           Map.update(player as address, Some
             (updatedCookieBaker), cookieBakers);
         return cookieBakers} else {return cookieBakers}},
       Temple: () => {
        let player = m.layerOneAddress;
        let cookieBaker: cookieBaker = 
          force_access(player as address, cookieBakers);
        if(cookieBaker.cookies >= cookieBaker.templeCost) {let temples = 
           cookieBaker.temples + (1 as nat);
         let cookies = 
           abs(cookieBaker.cookies - cookieBaker.templeCost);
         let updatedCookieBaker = 
           {...cookieBaker,
            cookies: cookies,
            temples: temples};
         let templeCost = 
           calculateCost(m.operation, updatedCookieBaker);
         let passiveCPS = calculateCPS(updatedCookieBaker);
         let updatedCookieBaker = 
           {...updatedCookieBaker,
            templeCost: templeCost,
            passiveCPS: passiveCPS};
         let cookieBakers = 
           Map.update(player as address, Some
             (updatedCookieBaker), cookieBakers);
         return cookieBakers} else {return cookieBakers}}})},
     Eat: eat => {
      let player = eat.layerOneAddress;
      let cookieBaker: cookieBaker = 
        force_access(player as address, cookieBakers);
      if(cookieBaker.cookies >= eat.amount) {let eatenCookies = 
         cookieBaker.eatenCookies + (eat.amount as nat);
       let cookies = 
         abs(cookieBaker.cookies - (eat.amount as nat));
       let cookieBakers = 
         Map.update(player as address, Some
           ({...cookieBaker,
            cookies: cookies,
            eatenCookies: eatenCookies}), cookieBakers);
       return cookieBakers} else {return cookieBakers}},
     Transfer: transfer => {
      let player = transfer.layerOneAddress;
      let sender: cookieBaker = 
        force_access(player as address, cookieBakers);
      if(sender.cookies >= transfer.amount) {let rawRecipient = transfer.recipient;
       let recipient = 
         force_access(rawRecipient as address, cookieBakers);
       let cookiesToTransfer = transfer.amount as nat;
       let senderCookies = 
         sender.cookies - cookiesToTransfer;
       let recipientCookies = 
         recipient.cookies + cookiesToTransfer;
       let cookieBakers = 
         Map.update(player as address, Some
           ({...sender, cookies: abs(senderCookies)}), cookieBakers);
       let cookieBakers = 
         Map.update(rawRecipient as address, Some
           ({...recipient, cookies: recipientCookies}), cookieBakers);
       return cookieBakers} else {return cookieBakers}},
     Delegate: delegation => {
      let player = delegation.layerOneAddress;
      let cookieBaker: cookieBaker = 
        force_access(player as address, cookieBakers);
      let authorizedKeys = 
         Set.add(delegation.address ,cookieBaker.authorizedKeys);
       let cookieBakers = 
         Map.update(player as address, Some
           ({...cookieBaker,
            authorizedKeys: authorizedKeys}), cookieBakers);
       return cookieBakers}})]};
